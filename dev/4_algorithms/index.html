<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · FiniteStateTransducers</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FiniteStateTransducers logo"/></a><div class="docs-package-name"><span class="docs-autofit">FiniteStateTransducers</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../1_intro/">Introduction</a></li><li><a class="tocitem" href="../2_semirings/">Weights</a></li><li><a class="tocitem" href="../3_wfsts/">Contructing WFSTs</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Arcmap"><span>Arcmap</span></a></li><li><a class="tocitem" href="#Closure"><span>Closure</span></a></li><li><a class="tocitem" href="#Composition"><span>Composition</span></a></li><li><a class="tocitem" href="#Concatenation"><span>Concatenation</span></a></li><li><a class="tocitem" href="#Connect"><span>Connect</span></a></li><li><a class="tocitem" href="#Determinize"><span>Determinize</span></a></li><li><a class="tocitem" href="#Epsilon-Removal"><span>Epsilon Removal</span></a></li><li><a class="tocitem" href="#Iterators"><span>Iterators</span></a></li><li><a class="tocitem" href="#Reverse"><span>Reverse</span></a></li><li><a class="tocitem" href="#Shortest-Distance"><span>Shortest Distance</span></a></li><li><a class="tocitem" href="#Topological-sort"><span>Topological sort</span></a></li><li><a class="tocitem" href="#WFST-label-transition-extraction"><span>WFST label transition extraction</span></a></li></ul></li><li><a class="tocitem" href="../5_io/">I/O</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/master/docs/src/4_algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Arcmap"><a class="docs-heading-anchor" href="#Arcmap">Arcmap</a><a id="Arcmap-1"></a><a class="docs-heading-anchor-permalink" href="#Arcmap" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.arcmap" href="#FiniteStateTransducers.arcmap"><code>FiniteStateTransducers.arcmap</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>arcmap(f::Function, fst::WFST, args...; modify_initials=identity, modify_finals=identity, isym=get_isym(fst), osym=get_osym(fst))</code></p><p>Creates a new WFST from <code>fst</code> by applying the function <code>f</code> to all its arcs, see <a href="../3_wfsts/#FiniteStateTransducers.Arc"><code>Arc</code></a>.  The arguments of <code>f</code> can be specified in <code>args</code>.</p><p>The functions <code>modify_initials</code> and <code>modify_finals</code> operate in the initial and final dictionaries, which keys are the initial/final states and values are the corresponding state weights.</p><p>Input and output tables can also be modified using the keywords <code>isym</code> and <code>osym</code>.</p><p>The following example shows how to use <code>arcmap</code> to convert the type of weight of a WFST:</p><pre><code class="language-julia">julia&gt; A = WFST([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]); # by default weight is TropicalWeight{Float32}

julia&gt; add_arc!(A,1=&gt;2,&quot;a&quot;=&gt;&quot;a&quot;,1);

julia&gt; add_arc!(A,1=&gt;3,&quot;b&quot;=&gt;&quot;c&quot;,3);

julia&gt; initial!(A,1); final!(A,2,4); final!(A,3,2)
WFST #states: 3, #arcs: 2, #isym: 3, #osym: 3
|1/0.0f0|
a:a/3.0f0 → (2)
b:c/3.0f0 → (3)
((2/4.0f0))
((3/2.0f0))

julia&gt; trop2prob(x) = ProbabilityWeight{Float64}(exp(-get(x)))
trop2prob (generic function with 1 method)

julia&gt; function trop2prob(arc::Arc)
           ilab = get_ilabel(arc)
           olab = get_olabel(arc)
           w = trop2prob(get_weight(arc))
           n = get_nextstate(arc)
           return Arc(ilab,olab,w,n)
       end
trop2prob (generic function with 2 methods)

julia&gt; trop2prob(initials::Dict) = Dict(i =&gt; trop2prob(w) for (i,w) in initials)
trop2prob (generic function with 3 methods)

julia&gt; arcmap(trop2prob,A; modify_initials=trop2prob, modify_finals=trop2prob)
WFST #states: 3, #arcs: 2, #isym: 3, #osym: 3
|1/1.0|
a:a/0.3678794503211975 → (2)
b:c/0.049787066876888275 → (3)
((2/0.018315639346837997))
((3/0.1353352814912796))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/arcmap.jl#L5-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv" href="#Base.inv"><code>Base.inv</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>inv(fst::WFST)</code></p><p>Inverts <code>fst</code> such that input labels are swaped with output labels.</p><pre><code class="language-julia">julia&gt; A = linearfst([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[1,2,3],ones(3))
WFST #states: 4, #arcs: 3, #isym: 3, #osym: 3
|1/1.0|
a:1/1.0 → (2)
(2)
b:2/1.0 → (3)
(3)
c:3/1.0 → (4)
((4/1.0))


julia&gt; inv(A)
WFST #states: 4, #arcs: 3, #isym: 3, #osym: 3
|1/1.0|
1:a/1.0 → (2)
(2)
2:b/1.0 → (3)
(3)
3:c/1.0 → (4)
((4/1.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/inv.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.proj" href="#FiniteStateTransducers.proj"><code>FiniteStateTransducers.proj</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>proj(get_iolabel::Function, fst::WFST)</code></p><p>Projects input labels to output labels (or viceversa). The function <code>get_iolabel</code> should either be the function <code>get_ilabel</code> or <code>get_olabel</code>.</p><pre><code class="language-julia">julia&gt; A = linearfst([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[1,2,3],ones(3))
WFST #states: 4, #arcs: 3, #isym: 3, #osym: 3
|1/1.0|
a:1/1.0 → (2)
(2)
b:2/1.0 → (3)
(3)
c:3/1.0 → (4)
((4/1.0))

julia&gt; proj(get_ilabel, A)
WFST #states: 4, #arcs: 3, #isym: 3, #osym: 3
|1/1.0|
a:a/1.0 → (2)
(2)
b:b/1.0 → (3)
(3)
c:c/1.0 → (4)
((4/1.0))

julia&gt; proj(get_olabel, A)
WFST #states: 4, #arcs: 3, #isym: 3, #osym: 3
|1/1.0|
1:1/1.0 → (2)
(2)
2:2/1.0 → (3)
(3)
3:3/1.0 → (4)
((4/1.0))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/proj.jl#L5-L43">source</a></section></article><h2 id="Closure"><a class="docs-heading-anchor" href="#Closure">Closure</a><a id="Closure-1"></a><a class="docs-heading-anchor-permalink" href="#Closure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.closure" href="#FiniteStateTransducers.closure"><code>FiniteStateTransducers.closure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>closure(fst; star=true)</code></p><p>Returns a new WFST <code>cfst</code> that is the closure of <code>fst</code>.  If <code>fst</code> transuces <code>labels</code> to <code>olabel</code> with weight <code>w</code>, <code>cfst</code> will be able to transduce <code>repeat(ilabels,n)</code> to <code>repeat(olabels,m)</code> with weight <code>w^n</code> for any integer <code>n</code>.</p><p>If <code>star</code> is <code>true</code>, <code>cfst</code> will transduce the empty string to itself with weight one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/closure.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.closure!" href="#FiniteStateTransducers.closure!"><code>FiniteStateTransducers.closure!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>closure!(fst; star=true)</code></p><p>Same as <code>closure</code> but modifies <code>fst</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/closure.jl#L5-L10">source</a></section></article><h2 id="Composition"><a class="docs-heading-anchor" href="#Composition">Composition</a><a id="Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Composition" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:∘" href="#Base.:∘"><code>Base.:∘</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>∘(A::WFST,B::WFST; filter=EpsSeq, connect=true)</code></p><p>Perform composition of the transucers <code>A</code> and <code>B</code>.</p><pre><code class="language-julia">julia&gt; A = linearfst([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;α&quot;,&quot;β&quot;,&quot;γ&quot;],ones(3))
WFST #states: 4, #arcs: 3, #isym: 3, #osym: 3
|1/0.0f0|
a:α/1.0f0 → (2)
(2)
b:β/1.0f0 → (3)
(3)
c:γ/1.0f0 → (4)
((4/0.0f0))

julia&gt; B = matrix2wfst([&quot;α&quot;,&quot;β&quot;,&quot;γ&quot;],[:w,:x,:z],ones(3,3))
WFST #states: 4, #arcs: 9, #isym: 3, #osym: 3
|1/0.0f0|
α:w/1.0f0 → (2)
β:x/1.0f0 → (2)
γ:z/1.0f0 → (2)
(2)
α:w/1.0f0 → (3)
β:x/1.0f0 → (3)
γ:z/1.0f0 → (3)
(3)
α:w/1.0f0 → (4)
β:x/1.0f0 → (4)
γ:z/1.0f0 → (4)
((4/0.0f0))

julia&gt; A∘B
WFST #states: 4, #arcs: 3, #isym: 3, #osym: 3
|1/0.0f0|
a:w/2.0f0 → (2)
(2)
b:x/2.0f0 → (3)
(3)
c:z/2.0f0 → (4)
((4/0.0f0))
</code></pre><p>The keyword <code>filter</code> can specify the composition filter to be used, which makes it possible to handle epsilon-transitions.  See <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36838.pdf">Allauzen et al. &quot;Filters for Efficient Composition of Weighted Finite-State Transducers&quot;</a>.</p><p>If <code>connect</code> is set to <code>true</code> after completing the composition the <a href="#FiniteStateTransducers.connect"><code>connect</code></a> algorithm is applied. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/compose.jl#L5-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.Trivial" href="#FiniteStateTransducers.Trivial"><code>FiniteStateTransducers.Trivial</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Trivial</code></p><p>Simplest composition filter, can be used for epsilon-free WFSTs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/compositionfilters.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.EpsMatch" href="#FiniteStateTransducers.EpsMatch"><code>FiniteStateTransducers.EpsMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>EpsMatch</code></p><p>Can be used for WFSTs containing epsilon labels. Avoids redundant epsilon paths and giving priority to those that match epsilon labels. </p><pre><code class="language-julia">julia&gt; A = txt2fst(&quot;0 1 a a 3.0
       1 2 b &lt;eps&gt; 77.0
       2 3 c &lt;eps&gt; 33.0
       3 4 d d 44.0
       4 90.0
       &quot;,Dict(&quot;a&quot;=&gt;1,&quot;b&quot;=&gt;2,&quot;c&quot;=&gt;3,&quot;d&quot;=&gt;4,&quot;e&quot;=&gt;5))
WFST #states: 5, #arcs: 4, #isym: 5, #osym: 5
|1/0.0f0|
a:a/3.0f0 → (2)
(2)
b:ϵ/77.0f0 → (3)
(3)
c:ϵ/33.0f0 → (4)
(4)
d:d/44.0f0 → (5)
((5/90.0f0))

julia&gt; B = txt2fst(&quot;0 1 a d 15.0
       1 2 &lt;eps&gt; e 19.0
       2 3 d a 12.0
       3 55.0
       &quot;,Dict(&quot;a&quot;=&gt;1,&quot;b&quot;=&gt;2,&quot;c&quot;=&gt;3,&quot;d&quot;=&gt;4,&quot;e&quot;=&gt;5))
WFST #states: 4, #arcs: 3, #isym: 5, #osym: 5
|1/0.0f0|
a:d/15.0f0 → (2)
(2)
ϵ:e/19.0f0 → (3)
(3)
d:a/12.0f0 → (4)
((4/55.0f0))

julia&gt; C = ∘(A,B;filter=EpsMatch)
WFST #states: 5, #arcs: 4, #isym: 5, #osym: 5
|1/0.0f0|
a:d/18.0f0 → (2)
(2)
b:e/96.0f0 → (3)
(3)
c:ϵ/33.0f0 → (4)
(4)
d:a/56.0f0 → 5)
((5/145.0f0))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/compositionfilters.jl#L41-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.EpsSeq" href="#FiniteStateTransducers.EpsSeq"><code>FiniteStateTransducers.EpsSeq</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>EpsSeq</code></p><p>Can be used for WFSTs containing epsilon labels. Avoids redundant epsilon paths.  Gives priority to epsilon paths consisting of epsilon-arcs in <code>A</code> followed by epsilon-arcs in <code>B</code>. </p><pre><code class="language-julia">julia&gt; A = txt2fst(&quot;0 1 a a 3.0
       1 2 b &lt;eps&gt; 77.0
       2 3 c &lt;eps&gt; 33.0
       3 4 d d 44.0
       4 90.0
       &quot;,Dict(&quot;a&quot;=&gt;1,&quot;b&quot;=&gt;2,&quot;c&quot;=&gt;3,&quot;d&quot;=&gt;4,&quot;e&quot;=&gt;5))
WFST #states: 5, #arcs: 4, #isym: 5, #osym: 5
|1/0.0f0|
a:a/3.0f0 → (2)
(2)
b:ϵ/77.0f0 → (3)
(3)
c:ϵ/33.0f0 → (4)
(4)
d:d/44.0f0 → (5)
((5/90.0f0))

julia&gt; B = txt2fst(&quot;0 1 a d 15.0
       1 2 &lt;eps&gt; e 19.0
       2 3 d a 12.0
       3 55.0
       &quot;,Dict(&quot;a&quot;=&gt;1,&quot;b&quot;=&gt;2,&quot;c&quot;=&gt;3,&quot;d&quot;=&gt;4,&quot;e&quot;=&gt;5))
WFST #states: 4, #arcs: 3, #isym: 5, #osym: 5
|1/0.0f0|
a:d/15.0f0 → (2)
(2)
ϵ:e/19.0f0 → (3)
(3)
d:a/12.0f0 → (4)
((4/55.0f0))

julia&gt; C = ∘(A,B;filter=EpsSeq)
WFST #states: 6, #arcs: 5, #isym: 5, #osym: 5
|1/0.0f0|
a:d/18.0f0 → (2)
(2)
b:ϵ/77.0f0 → (3)
(3)
c:ϵ/33.0f0 → (4)
(4)
ϵ:e/19.0f0 → (5)
(5)
d:a/56.0f0 → (6)
((6/145.0f0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/compositionfilters.jl#L121-L174">source</a></section></article><h2 id="Concatenation"><a class="docs-heading-anchor" href="#Concatenation">Concatenation</a><a id="Concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:*" href="#Base.:*"><code>Base.:*</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>*(A::WFST,B::WFST)</code></p><p>Returns <code>C</code>, the concatenation/product of <code>A</code> and <code>B</code>. If <code>A</code> converts the sequence <code>a_i</code> to <code>a_o</code> with weight <code>wa</code> and <code>B</code> converts the sequence <code>b_i</code> to <code>b_o</code> with weight <code>wb</code> then C<code>converts the sequence</code>[a<em>i,b</em>i]<code>to</code>[a<em>o,b</em>o]<code>with weight</code>wa*wb`.</p><pre><code class="language-julia">julia&gt; sym = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;α&quot;,&quot;β&quot;,&quot;γ&quot;,&quot;δ&quot;];

julia&gt; A = WFST(sym);

julia&gt; add_arc!(A,1=&gt;2,&quot;a&quot;=&gt;&quot;α&quot;);

julia&gt; add_arc!(A,2=&gt;3,&quot;b&quot;=&gt;&quot;β&quot;);

julia&gt; initial!(A,1); final!(A,3,5)
WFST #states: 3, #arcs: 2, #isym: 8, #osym: 8
|1/0.0f0|
a:α/0.0f0 → (2)
(2)
b:β/0.0f0 → (3)
((3/5.0f0))

julia&gt; B = WFST(sym);

julia&gt; add_arc!(B,1=&gt;2,&quot;c&quot;=&gt;&quot;γ&quot;);

julia&gt; add_arc!(B,2=&gt;3,&quot;d&quot;=&gt;&quot;δ&quot;);

julia&gt; initial!(B,1); final!(B,3,2)
WFST #states: 3, #arcs: 2, #isym: 8, #osym: 8
|1/0.0f0|
c:γ/0.0f0 → (2)
(2)
d:δ/0.0f0 → (3)
((3/2.0f0))

julia&gt; C = A*B
WFST #states: 6, #arcs: 5, #isym: 8, #osym: 8
|1/0.0f0|
a:α/0.0f0 → (2)
(2)
b:β/0.0f0 → (3)
(3)
ϵ:ϵ/5.0f0 → (4)
(4)
c:γ/0.0f0 → (5)
(5)
d:δ/0.0f0 → (6)
((6/2.0f0))

julia&gt; A([&quot;a&quot;,&quot;b&quot;])
([&quot;α&quot;, &quot;β&quot;], 5.0f0)

julia&gt; B([&quot;c&quot;,&quot;d&quot;])
([&quot;γ&quot;, &quot;δ&quot;], 2.0f0)

julia&gt; C([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])
([&quot;α&quot;, &quot;β&quot;, &quot;γ&quot;, &quot;δ&quot;], 7.0f0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/cat.jl#L5-L65">source</a></section></article><h2 id="Connect"><a class="docs-heading-anchor" href="#Connect">Connect</a><a id="Connect-1"></a><a class="docs-heading-anchor-permalink" href="#Connect" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.connect" href="#FiniteStateTransducers.connect"><code>FiniteStateTransducers.connect</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>connect(fst::WFST, [i = get_initial(fst,single=true)])</code></p><p>Remove states that do not belong to paths that end in final states when starting from <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/connect.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.connect!" href="#FiniteStateTransducers.connect!"><code>FiniteStateTransducers.connect!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>connect!(fst::WFST, [i = get_initial(fst,single=true)])</code></p><p>Same as <code>connect</code> but modifies <code>fst</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/connect.jl#L5-L9">source</a></section></article><h2 id="Determinize"><a class="docs-heading-anchor" href="#Determinize">Determinize</a><a id="Determinize-1"></a><a class="docs-heading-anchor-permalink" href="#Determinize" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.determinize_fsa" href="#FiniteStateTransducers.determinize_fsa"><code>FiniteStateTransducers.determinize_fsa</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>determinize_fsa(fsa)</code></p><p>Returns a deterministic finite state acceptor. <code>fsa</code> must be an acceptor (<a href="../3_wfsts/#FiniteStateTransducers.is_acceptor"><code>is_acceptor</code></a>).</p><p>Requires the WFST to be defined in a left distributive and weakly divisible semiring.</p><p>See <a href="https://cs.nyu.edu/~mohri/pub/hbka.pdf">M. Mohri, F. Pereira, Fernando, M. Riley, Michael &quot;Speech Recognition with Weighted Finite-State Transducers&quot; in Springer Handb. Speech Process. 2008</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/determinize.jl#L5-L13">source</a></section></article><h2 id="Epsilon-Removal"><a class="docs-heading-anchor" href="#Epsilon-Removal">Epsilon Removal</a><a id="Epsilon-Removal-1"></a><a class="docs-heading-anchor-permalink" href="#Epsilon-Removal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.rm_eps" href="#FiniteStateTransducers.rm_eps"><code>FiniteStateTransducers.rm_eps</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rm_eps(fst::WFST)</code></p><p>Returns an equivalent WFST where arcs with input and output labels are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/rm_eps.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.rm_eps!" href="#FiniteStateTransducers.rm_eps!"><code>FiniteStateTransducers.rm_eps!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rm_eps!(fst::WFST)</code></p><p>Same as <code>rm_eps</code> but operates in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/rm_eps.jl#L7-L11">source</a></section></article><h2 id="Iterators"><a class="docs-heading-anchor" href="#Iterators">Iterators</a><a id="Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Iterators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.BFS" href="#FiniteStateTransducers.BFS"><code>FiniteStateTransducers.BFS</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>BFS(fst,initial)</code></p><p>Returns an iterator that performs a breadth-first search (BFS) of <code>fst</code> starting from the state <code>initial</code>.</p><p>At each iteartion the tuple <code>(i,p)</code> is returned, where <code>i</code> is the current state and <code>p</code> a <a href="../3_wfsts/#FiniteStateTransducers.Path"><code>Path</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/iterators/bfs.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.get_paths" href="#FiniteStateTransducers.get_paths"><code>FiniteStateTransducers.get_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_paths(fst::FST, [i = get_initial(fst;single=true)])</code></p><p>Returns an iterator that generates all of the possible paths of <code>fst</code> starting from <code>i</code>.</p><p>Notice that the <code>fst</code> must be acyclic for the algorithm to stop (see <a href="../3_wfsts/#FiniteStateTransducers.is_acyclic"><code>is_acyclic</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/allpaths.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.collectpaths" href="#FiniteStateTransducers.collectpaths"><code>FiniteStateTransducers.collectpaths</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>collectpaths(fst::FST, [i = get_initial(fst;first=true)])</code></p><p>Returns an array containing all of the possible paths of <code>fst</code> starting from <code>i</code>.</p><p>Notice that the <code>fst</code> must be acyclic for the algorithm to stop (see <a href="../3_wfsts/#FiniteStateTransducers.is_acyclic"><code>is_acyclic</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/allpaths.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.DFS" href="#FiniteStateTransducers.DFS"><code>FiniteStateTransducers.DFS</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DFS(fst::WFST, initial; filter=arc-&gt;true)</code></p><p>Creates an iterator that performs a depth-first search (DFS) of the <code>fst</code> starting from the state <code>initial</code>. The function filter can be specify in order to perform the search ignoring arcs with user-defined properties.</p><p>For each iterator the tuple <code>(p,s,n,d,e)</code> is returned, where: </p><ul><li><code>p</code> is the parent parent state (p==0 if there is no parent)</li><li><code>s</code> is the current state</li><li><code>n</code> next state: <code>n==0</code> if <code>s</code> has no arcs or if completely explored. These will give you standard DFS iterations.</li><li><code>d</code> is a <code>Bool</code>: if <code>true</code> means a new state is discovered, can be used to pick up DFS its (see example below)</li><li><code>e</code> is a <code>Bool</code>, if <code>true</code> means all arcs have been inspected</li><li><code>a</code> inspected arc (empty if <code>d == false</code>) </li></ul><p>The following cases/colors are possible:</p><ul><li><code>d == false &amp;&amp; n ==0</code> -&gt; black state, state has been checked completely</li><li><code>d == false &amp;&amp; n !=0</code> -&gt; <code>n</code> is already gray</li><li><code>d == true -&gt; n</code> state is colored gray, i.e. is visited for the first time</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; fst = WFST(Dict(1=&gt;1));

julia&gt; add_arc!(fst, 1, 2, 1, 1, 1.0);

julia&gt; add_arc!(fst, 1, 5, 1, 1, 1.0);

julia&gt; add_arc!(fst, 1, 3, 1, 1, 1.0);

julia&gt; add_arc!(fst, 2, 6, 1, 1, 1.0);

julia&gt; add_arc!(fst, 2, 4, 1, 1, 1.0);

julia&gt; add_arc!(fst, 5, 4, 1, 1, 1.0);

julia&gt; add_arc!(fst, 3, 4, 1, 1, 1.0);

julia&gt; add_arc!(fst, 3, 7, 1, 1, 1.0);

julia&gt; initial!(fst,1)
WFST #states: 7, #arcs: 8, #isym: 1, #osym: 1
|1/0.0f0|
1:1/1.0f0 → (2)
1:1/1.0f0 → (5)
1:1/1.0f0 → (3)
(2)
1:1/1.0f0 → (6)
1:1/1.0f0 → (4)
(3)
1:1/1.0f0 → (4)
1:1/1.0f0 → (7)
(4)
(5)
1:1/1.0f0 → (4)
(6)
(7)

julia&gt; dfs = FiniteStateTransducers.DFS(fst,1); # DFS starting from state 1

julia&gt; for (p,s,n,d,e,a) in dfs
         println(&quot;$p,$s,$n&quot;)
         if d == true
           println(&quot;visiting first time $n (Gray)&quot;)
         else
           if e
             println(&quot;completed state $s (Black)&quot;)
           else
             println(&quot;node $n already visited&quot;)
           end
         end
       end
0,1,2
visiting first time 2 (Gray)
1,2,6
visiting first time 6 (Gray)
2,6,0
completed state 6 (Black)
1,2,4
visiting first time 4 (Gray)
2,4,0
completed state 4 (Black)
1,2,0
completed state 2 (Black)
0,1,5
visiting first time 5 (Gray)
1,5,4
node 4 already visited
1,5,0
completed state 5 (Black)
0,1,3
visiting first time 3 (Gray)
1,3,4
node 4 already visited
1,3,7
visiting first time 7 (Gray)
3,7,0
completed state 7 (Black)
1,3,0
completed state 3 (Black)
0,1,0
completed state 1 (Black)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/iterators/dfs.jl#L6-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.is_visited" href="#FiniteStateTransducers.is_visited"><code>FiniteStateTransducers.is_visited</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_visited(fst::WFST, i = get_initial(fst;single=true))</code></p><p>Return an array of booleans indicating if the i-th state of the fst is visted starting form <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/is_visited.jl#L5-L9">source</a></section></article><h2 id="Reverse"><a class="docs-heading-anchor" href="#Reverse">Reverse</a><a id="Reverse-1"></a><a class="docs-heading-anchor-permalink" href="#Reverse" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>reverse(fst::WFST)</code></p><p>Returns <code>rfst</code>, the reversed version of <code>fst</code>. If <code>fst</code> transuces the sequence <code>x</code> to <code>y</code> with weight <code>w</code>, <code>rfst</code> transuces the reverse of <code>x</code> to the reverse of <code>y</code> with weight <code>reverse(w)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/reverse.jl#L5-L10">source</a></section></article><h2 id="Shortest-Distance"><a class="docs-heading-anchor" href="#Shortest-Distance">Shortest Distance</a><a id="Shortest-Distance-1"></a><a class="docs-heading-anchor-permalink" href="#Shortest-Distance" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.shortest_distance" href="#FiniteStateTransducers.shortest_distance"><code>FiniteStateTransducers.shortest_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>shortest_distance(fst[, s=get_initial(fst); filter=arc-&gt;true, reverse=false)</code></p><p>Computes the shortest distance between the state <code>s</code> to every other state. The shortest distance between <code>s</code> and <code>i</code> is defined as the sum of the weights of all paths between these states.</p><p>Weights are required to be rigth distributive and k-closed.</p><p>If <code>fst</code> has <code>N</code> states a <code>N</code>-long vector is returned where the <code>i</code>-the element contains the shortest distance between the states <code>s</code> and <code>i</code>.</p><p>If <code>reversed==true</code> the shortest distance from the final states is computed. In this case <code>s</code> has no effect since a new initial superstate is added to the reversed WFST. Here weights are required to be left distributive and k-closed. </p><p>See Mohri &quot;Semiring framework and algorithms for shortest-distance problems&quot;, Journal of Automata, Languages and Combinatorics 7(3): 321-350, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/shortest_distance.jl#L6-L22">source</a></section></article><h2 id="Topological-sort"><a class="docs-heading-anchor" href="#Topological-sort">Topological sort</a><a id="Topological-sort-1"></a><a class="docs-heading-anchor-permalink" href="#Topological-sort" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.topsort" href="#FiniteStateTransducers.topsort"><code>FiniteStateTransducers.topsort</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>topsort(fst::WFST, i = get_initial(fst); filter=arc-&gt;true)</code></p><p>Requires <code>fst</code> to be acyclic.</p><p>Returns an equivalent WFST to <code>fst</code> which is topologically sorted starting from the <code>i</code>-th state.</p><p>Modify the <code>filter</code> function to perform the operation considering only specific arcs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/topsort.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.topsortperm" href="#FiniteStateTransducers.topsortperm"><code>FiniteStateTransducers.topsortperm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>topsortperm(fst::WFST, i = get_initial(fst); filter=arc-&gt;true)</code></p><p>Requires <code>fst</code> to be acyclic.</p><p>Returns the topological permutation of states of <code>fst</code> starting from the <code>i</code>-th state.</p><p>Modify the <code>filter</code> function to perform the operation considering only specific arcs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/topsort.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.get_scc" href="#FiniteStateTransducers.get_scc"><code>FiniteStateTransducers.get_scc</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_scc(fst::WFST, i = get_initial(fst;single=true); filter=arc-&gt;true)</code></p><p>Calculates the strongly connected components of &#39;fst&#39; using Tarjan&#39;s algorithm. Returns a tuple <code>(scc,c,v)</code>:</p><ul><li><code>scc</code> are the strongly connected components of <code>fst</code></li><li><code>c</code> is a boolean array containing the accessibility form the <code>i</code></li><li><code>v</code> are the visited states of the <code>fst</code></li></ul><p>The function <code>filter</code> can be used to consider only arcs with specific properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/get_scc.jl#L5-L14">source</a></section></article><h2 id="WFST-label-transition-extraction"><a class="docs-heading-anchor" href="#WFST-label-transition-extraction">WFST label transition extraction</a><a id="WFST-label-transition-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#WFST-label-transition-extraction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateTransducers.wfst2tr" href="#FiniteStateTransducers.wfst2tr"><code>FiniteStateTransducers.wfst2tr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>wfst2tr(fst,Nt; get_label=get_ilabel)</code></p><p>Returns an array <code>time2tr</code> of length <code>Nt-1</code>. The <code>t</code>-th element of <code>time2tr</code> is a dictionary mapping the transition index between input label at time <code>t</code> to the input label at time <code>t+1</code>.</p><pre><code class="language-julia">julia&gt; using FiniteStateTransducers

julia&gt; H = WFST([&quot;a1&quot;,&quot;a2&quot;,&quot;a3&quot;],[&quot;a&quot;]);

julia&gt; add_arc!(H,1,2,&quot;a1&quot;,&quot;a&quot;);

julia&gt; add_arc!(H,2,3,&quot;a2&quot;,&quot;&lt;eps&gt;&quot;);

julia&gt; add_arc!(H,2,2,&quot;a2&quot;,&quot;&lt;eps&gt;&quot;);

julia&gt; add_arc!(H,3,4,&quot;a3&quot;,&quot;&lt;eps&gt;&quot;);

julia&gt; add_arc!(H,3,2,&quot;a3&quot;,&quot;a&quot;);

julia&gt; initial!(H,1);

julia&gt; final!(H,4)
WFST #states: 4, #arcs: 5, #isym: 3, #osym: 1
|1/0.0f0|
a1:a/0.0f0 → (2)
(2)
a2:ϵ/0.0f0 → (3)
a2:ϵ/0.0f0 → (2)
(3)
a3:ϵ/0.0f0 → (4)
a3:a/0.0f0 → (2)
((4/0.0f0))


julia&gt; Nt = 10;

julia&gt; time2tr = wfst2tr(H,Nt)
9-element Array{Dict{Int64,Array{Int64,1}},1}:
 Dict(1 =&gt; [2])
 Dict(2 =&gt; [2, 3])
 Dict(2 =&gt; [2, 3],3 =&gt; [2])
 Dict(2 =&gt; [2, 3],3 =&gt; [2])
 Dict(2 =&gt; [2, 3],3 =&gt; [2])
 Dict(2 =&gt; [2, 3],3 =&gt; [2])
 Dict(2 =&gt; [2, 3],3 =&gt; [2])
 Dict(2 =&gt; [2],3 =&gt; [2])
 Dict(2 =&gt; [3])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/wfst2tr.jl#L5-L57">source</a></section><section><div><p><code>wfst2tr(fst; get_label=get_ilabel, convert_weight=identity)</code></p><p>Extract transition matrix and initial probabilities from a WFST representing an HMM model.</p><pre><code class="language-julia">julia&gt; add_arc!(H,1,2,&quot;a1&quot;,&quot;a&quot;);

julia&gt; add_arc!(H,2,2,&quot;a1&quot;,&quot;&lt;eps&gt;&quot;,-log(0.3));

julia&gt; add_arc!(H,2,3,&quot;a2&quot;,&quot;&lt;eps&gt;&quot;,-log(0.7));

julia&gt; add_arc!(H,3,3,&quot;a2&quot;,&quot;&lt;eps&gt;&quot;,-log(0.3));

julia&gt; add_arc!(H,3,4,&quot;a3&quot;,&quot;&lt;eps&gt;&quot;,-log(0.7));

julia&gt; add_arc!(H,4,4,&quot;a3&quot;,&quot;&lt;eps&gt;&quot;,-log(0.3));

julia&gt; add_arc!(H,4,2,&quot;a1&quot;,&quot;a&quot;,-log(0.7));

julia&gt; initial!(H,1);

julia&gt; final!(H,4)
WFST #states: 4, #arcs: 12, #isym: 3, #osym: 1
|1/0.0f0|
a1:a/0.0f0 → (2)
a1:a/0.0f0 → (2)
(2)
a2:ϵ/0.0f0 → (3)
a2:ϵ/0.0f0 → (2)
a1:ϵ/1.2039728f0 → (2)
a2:ϵ/0.35667494f0 → (3)
(3)
a3:ϵ/0.0f0 → (4)
a3:a/0.0f0 → (2)
a2:ϵ/1.2039728f0 → (3)
a3:ϵ/0.35667494f0 → (4)
((4/0.0f0))
a3:ϵ/1.2039728f0 → (4)
a1:a/0.35667494f0 → (2)

julia&gt; a,A = wfst2tr(H; convert_weight = w -&gt; exp(-get(w)))
(Float32[1.0, 0.0, 0.0], Float32[0.3 0.7 0.0; 0.0 0.3 0.7; 0.7 0.0 0.3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/idiap/FiniteStateTransducers.jl/blob/046c104edb4c094d1b6ccd68267cf8af39d44477/src/algorithms/wfst2tr.jl#L100-L144">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3_wfsts/">« Contructing WFSTs</a><a class="docs-footer-nextpage" href="../5_io/">I/O »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 10 March 2021 11:48">Wednesday 10 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
