var documenterSearchIndex = {"docs":
[{"location":"4_algorithms/#Arcmap","page":"Algorithms","title":"Arcmap","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"arcmap\ninv\nproj","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.arcmap","page":"Algorithms","title":"FiniteStateTransducers.arcmap","text":"arcmap(f::Function, fst::WFST, args...; modify_initials=identity, modify_finals=identity, isym=get_isym(fst), osym=get_osym(fst))\n\nCreates a new WFST from fst by applying the function f to all its arcs, see Arc.  The arguments of f can be specified in args.\n\nThe functions modify_initials and modify_finals operate in the initial and final dictionaries, which keys are the initial/final states and values are the corresponding state weights.\n\nInput and output tables can also be modified using the keywords isym and osym.\n\nThe following example shows how to use arcmap to convert the type of weight of a WFST:\n\njulia> A = WFST([\"a\",\"b\",\"c\"]); # by default weight is TropicalWeight{Float32}\n\njulia> add_arc!(A,1=>2,\"a\"=>\"a\",1);\n\njulia> add_arc!(A,1=>3,\"b\"=>\"c\",3);\n\njulia> initial!(A,1); final!(A,2,4); final!(A,3,2)\nWFST #states: 3, #arcs: 2, #isym: 3, #osym: 3\n|1/0.0f0|\na:a/3.0f0 → (2)\nb:c/3.0f0 → (3)\n((2/4.0f0))\n((3/2.0f0))\n\njulia> trop2prob(x) = ProbabilityWeight{Float64}(exp(-get(x)))\ntrop2prob (generic function with 1 method)\n\njulia> function trop2prob(arc::Arc)\n           ilab = get_ilabel(arc)\n           olab = get_olabel(arc)\n           w = trop2prob(get_weight(arc))\n           n = get_nextstate(arc)\n           return Arc(ilab,olab,w,n)\n       end\ntrop2prob (generic function with 2 methods)\n\njulia> trop2prob(initials::Dict) = Dict(i => trop2prob(w) for (i,w) in initials)\ntrop2prob (generic function with 3 methods)\n\njulia> arcmap(trop2prob,A; modify_initials=trop2prob, modify_finals=trop2prob)\nWFST #states: 3, #arcs: 2, #isym: 3, #osym: 3\n|1/1.0|\na:a/0.3678794503211975 → (2)\nb:c/0.049787066876888275 → (3)\n((2/0.018315639346837997))\n((3/0.1353352814912796))\n\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Base.inv","page":"Algorithms","title":"Base.inv","text":"inv(fst::WFST)\n\nInverts fst such that input labels are swaped with output labels.\n\njulia> A = linearfst([\"a\",\"b\",\"c\"],[1,2,3],ones(3))\nWFST #states: 4, #arcs: 3, #isym: 3, #osym: 3\n|1/1.0|\na:1/1.0 → (2)\n(2)\nb:2/1.0 → (3)\n(3)\nc:3/1.0 → (4)\n((4/1.0))\n\n\njulia> inv(A)\nWFST #states: 4, #arcs: 3, #isym: 3, #osym: 3\n|1/1.0|\n1:a/1.0 → (2)\n(2)\n2:b/1.0 → (3)\n(3)\n3:c/1.0 → (4)\n((4/1.0))\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.proj","page":"Algorithms","title":"FiniteStateTransducers.proj","text":"proj(get_iolabel::Function, fst::WFST)\n\nProjects input labels to output labels (or viceversa). The function get_iolabel should either be the function get_ilabel or get_olabel.\n\njulia> A = linearfst([\"a\",\"b\",\"c\"],[1,2,3],ones(3))\nWFST #states: 4, #arcs: 3, #isym: 3, #osym: 3\n|1/1.0|\na:1/1.0 → (2)\n(2)\nb:2/1.0 → (3)\n(3)\nc:3/1.0 → (4)\n((4/1.0))\n\njulia> proj(get_ilabel, A)\nWFST #states: 4, #arcs: 3, #isym: 3, #osym: 3\n|1/1.0|\na:a/1.0 → (2)\n(2)\nb:b/1.0 → (3)\n(3)\nc:c/1.0 → (4)\n((4/1.0))\n\njulia> proj(get_olabel, A)\nWFST #states: 4, #arcs: 3, #isym: 3, #osym: 3\n|1/1.0|\n1:1/1.0 → (2)\n(2)\n2:2/1.0 → (3)\n(3)\n3:3/1.0 → (4)\n((4/1.0))\n\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Closure","page":"Algorithms","title":"Closure","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"closure\nclosure!","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.closure","page":"Algorithms","title":"FiniteStateTransducers.closure","text":"closure(fst; star=true)\n\nReturns a new WFST cfst that is the closure of fst.  If fst transuces labels to olabel with weight w, cfst will be able to transduce repeat(ilabels,n) to repeat(olabels,m) with weight w^n for any integer n.\n\nIf star is true, cfst will transduce the empty string to itself with weight one.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.closure!","page":"Algorithms","title":"FiniteStateTransducers.closure!","text":"closure!(fst; star=true)\n\nSame as closure but modifies fst in-place.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Composition","page":"Algorithms","title":"Composition","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"∘\nTrivial\nEpsMatch\nEpsSeq","category":"page"},{"location":"4_algorithms/#Base.:∘","page":"Algorithms","title":"Base.:∘","text":"∘(A::WFST,B::WFST; filter=EpsSeq, connect=true)\n\nPerform composition of the transucers A and B.\n\njulia> A = linearfst([\"a\",\"b\",\"c\"],[\"α\",\"β\",\"γ\"],ones(3))\nWFST #states: 4, #arcs: 3, #isym: 3, #osym: 3\n|1/0.0f0|\na:α/1.0f0 → (2)\n(2)\nb:β/1.0f0 → (3)\n(3)\nc:γ/1.0f0 → (4)\n((4/0.0f0))\n\njulia> B = matrix2wfst([\"α\",\"β\",\"γ\"],[:w,:x,:z],ones(3,3))\nWFST #states: 4, #arcs: 9, #isym: 3, #osym: 3\n|1/0.0f0|\nα:w/1.0f0 → (2)\nβ:x/1.0f0 → (2)\nγ:z/1.0f0 → (2)\n(2)\nα:w/1.0f0 → (3)\nβ:x/1.0f0 → (3)\nγ:z/1.0f0 → (3)\n(3)\nα:w/1.0f0 → (4)\nβ:x/1.0f0 → (4)\nγ:z/1.0f0 → (4)\n((4/0.0f0))\n\njulia> A∘B\nWFST #states: 4, #arcs: 3, #isym: 3, #osym: 3\n|1/0.0f0|\na:w/2.0f0 → (2)\n(2)\nb:x/2.0f0 → (3)\n(3)\nc:z/2.0f0 → (4)\n((4/0.0f0))\n\n\nThe keyword filter can specify the composition filter to be used, which makes it possible to handle epsilon-transitions.  See Allauzen et al. \"Filters for Efficient Composition of Weighted Finite-State Transducers\".\n\nIf connect is set to true after completing the composition the connect algorithm is applied. \n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.Trivial","page":"Algorithms","title":"FiniteStateTransducers.Trivial","text":"Trivial\n\nSimplest composition filter, can be used for epsilon-free WFSTs.\n\n\n\n\n\n","category":"type"},{"location":"4_algorithms/#FiniteStateTransducers.EpsMatch","page":"Algorithms","title":"FiniteStateTransducers.EpsMatch","text":"EpsMatch\n\nCan be used for WFSTs containing epsilon labels. Avoids redundant epsilon paths and giving priority to those that match epsilon labels. \n\njulia> A = txt2fst(\"0 1 a a 3.0\n       1 2 b <eps> 77.0\n       2 3 c <eps> 33.0\n       3 4 d d 44.0\n       4 90.0\n       \",Dict(\"a\"=>1,\"b\"=>2,\"c\"=>3,\"d\"=>4,\"e\"=>5))\nWFST #states: 5, #arcs: 4, #isym: 5, #osym: 5\n|1/0.0f0|\na:a/3.0f0 → (2)\n(2)\nb:ϵ/77.0f0 → (3)\n(3)\nc:ϵ/33.0f0 → (4)\n(4)\nd:d/44.0f0 → (5)\n((5/90.0f0))\n\njulia> B = txt2fst(\"0 1 a d 15.0\n       1 2 <eps> e 19.0\n       2 3 d a 12.0\n       3 55.0\n       \",Dict(\"a\"=>1,\"b\"=>2,\"c\"=>3,\"d\"=>4,\"e\"=>5))\nWFST #states: 4, #arcs: 3, #isym: 5, #osym: 5\n|1/0.0f0|\na:d/15.0f0 → (2)\n(2)\nϵ:e/19.0f0 → (3)\n(3)\nd:a/12.0f0 → (4)\n((4/55.0f0))\n\njulia> C = ∘(A,B;filter=EpsMatch)\nWFST #states: 5, #arcs: 4, #isym: 5, #osym: 5\n|1/0.0f0|\na:d/18.0f0 → (2)\n(2)\nb:e/96.0f0 → (3)\n(3)\nc:ϵ/33.0f0 → (4)\n(4)\nd:a/56.0f0 → 5)\n((5/145.0f0))\n\n\n\n\n\n\n","category":"type"},{"location":"4_algorithms/#FiniteStateTransducers.EpsSeq","page":"Algorithms","title":"FiniteStateTransducers.EpsSeq","text":"EpsSeq\n\nCan be used for WFSTs containing epsilon labels. Avoids redundant epsilon paths.  Gives priority to epsilon paths consisting of epsilon-arcs in A followed by epsilon-arcs in B. \n\njulia> A = txt2fst(\"0 1 a a 3.0\n       1 2 b <eps> 77.0\n       2 3 c <eps> 33.0\n       3 4 d d 44.0\n       4 90.0\n       \",Dict(\"a\"=>1,\"b\"=>2,\"c\"=>3,\"d\"=>4,\"e\"=>5))\nWFST #states: 5, #arcs: 4, #isym: 5, #osym: 5\n|1/0.0f0|\na:a/3.0f0 → (2)\n(2)\nb:ϵ/77.0f0 → (3)\n(3)\nc:ϵ/33.0f0 → (4)\n(4)\nd:d/44.0f0 → (5)\n((5/90.0f0))\n\njulia> B = txt2fst(\"0 1 a d 15.0\n       1 2 <eps> e 19.0\n       2 3 d a 12.0\n       3 55.0\n       \",Dict(\"a\"=>1,\"b\"=>2,\"c\"=>3,\"d\"=>4,\"e\"=>5))\nWFST #states: 4, #arcs: 3, #isym: 5, #osym: 5\n|1/0.0f0|\na:d/15.0f0 → (2)\n(2)\nϵ:e/19.0f0 → (3)\n(3)\nd:a/12.0f0 → (4)\n((4/55.0f0))\n\njulia> C = ∘(A,B;filter=EpsSeq)\nWFST #states: 6, #arcs: 5, #isym: 5, #osym: 5\n|1/0.0f0|\na:d/18.0f0 → (2)\n(2)\nb:ϵ/77.0f0 → (3)\n(3)\nc:ϵ/33.0f0 → (4)\n(4)\nϵ:e/19.0f0 → (5)\n(5)\nd:a/56.0f0 → (6)\n((6/145.0f0))\n\n\n\n\n\n","category":"type"},{"location":"4_algorithms/#Concatenation","page":"Algorithms","title":"Concatenation","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"*","category":"page"},{"location":"4_algorithms/#Base.:*","page":"Algorithms","title":"Base.:*","text":"*(A::WFST,B::WFST)\n\nReturns C, the concatenation/product of A and B. If A converts the sequence a_i to a_o with weight wa and B converts the sequence b_i to b_o with weight wb then Cconverts the sequence[ai,bi]to[ao,bo]with weightwa*wb`.\n\njulia> sym = [\"a\",\"b\",\"c\",\"d\",\"α\",\"β\",\"γ\",\"δ\"];\n\njulia> A = WFST(sym);\n\njulia> add_arc!(A,1=>2,\"a\"=>\"α\");\n\njulia> add_arc!(A,2=>3,\"b\"=>\"β\");\n\njulia> initial!(A,1); final!(A,3,5)\nWFST #states: 3, #arcs: 2, #isym: 8, #osym: 8\n|1/0.0f0|\na:α/0.0f0 → (2)\n(2)\nb:β/0.0f0 → (3)\n((3/5.0f0))\n\njulia> B = WFST(sym);\n\njulia> add_arc!(B,1=>2,\"c\"=>\"γ\");\n\njulia> add_arc!(B,2=>3,\"d\"=>\"δ\");\n\njulia> initial!(B,1); final!(B,3,2)\nWFST #states: 3, #arcs: 2, #isym: 8, #osym: 8\n|1/0.0f0|\nc:γ/0.0f0 → (2)\n(2)\nd:δ/0.0f0 → (3)\n((3/2.0f0))\n\njulia> C = A*B\nWFST #states: 6, #arcs: 5, #isym: 8, #osym: 8\n|1/0.0f0|\na:α/0.0f0 → (2)\n(2)\nb:β/0.0f0 → (3)\n(3)\nϵ:ϵ/5.0f0 → (4)\n(4)\nc:γ/0.0f0 → (5)\n(5)\nd:δ/0.0f0 → (6)\n((6/2.0f0))\n\njulia> A([\"a\",\"b\"])\n([\"α\", \"β\"], 5.0f0)\n\njulia> B([\"c\",\"d\"])\n([\"γ\", \"δ\"], 2.0f0)\n\njulia> C([\"a\",\"b\",\"c\",\"d\"])\n([\"α\", \"β\", \"γ\", \"δ\"], 7.0f0)\n\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Connect","page":"Algorithms","title":"Connect","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"connect\nconnect!","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.connect","page":"Algorithms","title":"FiniteStateTransducers.connect","text":"connect(fst::WFST, [i = get_initial(fst,single=true)])\n\nRemove states that do not belong to paths that end in final states when starting from i.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.connect!","page":"Algorithms","title":"FiniteStateTransducers.connect!","text":"connect!(fst::WFST, [i = get_initial(fst,single=true)])\n\nSame as connect but modifies fst in-place.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Determinize","page":"Algorithms","title":"Determinize","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"determinize_fsa","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.determinize_fsa","page":"Algorithms","title":"FiniteStateTransducers.determinize_fsa","text":"determinize_fsa(fsa)\n\nReturns a deterministic finite state acceptor. fsa must be an acceptor (is_acceptor).\n\nRequires the WFST to be defined in a left distributive and weakly divisible semiring.\n\nSee M. Mohri, F. Pereira, Fernando, M. Riley, Michael \"Speech Recognition with Weighted Finite-State Transducers\" in Springer Handb. Speech Process. 2008 for details.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Epsilon-Removal","page":"Algorithms","title":"Epsilon Removal","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"rm_eps\nrm_eps!","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.rm_eps","page":"Algorithms","title":"FiniteStateTransducers.rm_eps","text":"rm_eps(fst::WFST)\n\nReturns an equivalent WFST where arcs with input and output labels are removed.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.rm_eps!","page":"Algorithms","title":"FiniteStateTransducers.rm_eps!","text":"rm_eps!(fst::WFST)\n\nSame as rm_eps but operates in place.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Iterators","page":"Algorithms","title":"Iterators","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"BFS\nget_paths\ncollectpaths\nDFS\nis_visited","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.BFS","page":"Algorithms","title":"FiniteStateTransducers.BFS","text":"BFS(fst,initial)\n\nReturns an iterator that performs a breadth-first search (BFS) of fst starting from the state initial.\n\nAt each iteartion the tuple (i,p) is returned, where i is the current state and p a Path.\n\n\n\n\n\n","category":"type"},{"location":"4_algorithms/#FiniteStateTransducers.get_paths","page":"Algorithms","title":"FiniteStateTransducers.get_paths","text":"get_paths(fst::FST, [i = get_initial(fst;single=true)])\n\nReturns an iterator that generates all of the possible paths of fst starting from i.\n\nNotice that the fst must be acyclic for the algorithm to stop (see is_acyclic).\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.collectpaths","page":"Algorithms","title":"FiniteStateTransducers.collectpaths","text":"collectpaths(fst::FST, [i = get_initial(fst;first=true)])\n\nReturns an array containing all of the possible paths of fst starting from i.\n\nNotice that the fst must be acyclic for the algorithm to stop (see is_acyclic).\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.DFS","page":"Algorithms","title":"FiniteStateTransducers.DFS","text":"DFS(fst::WFST, initial; filter=arc->true)\n\nCreates an iterator that performs a depth-first search (DFS) of the fst starting from the state initial. The function filter can be specify in order to perform the search ignoring arcs with user-defined properties.\n\nFor each iterator the tuple (p,s,n,d,e) is returned, where: \n\np is the parent parent state (p==0 if there is no parent)\ns is the current state\nn next state: n==0 if s has no arcs or if completely explored. These will give you standard DFS iterations.\nd is a Bool: if true means a new state is discovered, can be used to pick up DFS its (see example below)\ne is a Bool, if true means all arcs have been inspected\na inspected arc (empty if d == false) \n\nThe following cases/colors are possible:\n\nd == false && n ==0 -> black state, state has been checked completely\nd == false && n !=0 -> n is already gray\nd == true -> n state is colored gray, i.e. is visited for the first time\n\nExample\n\njulia> fst = WFST(Dict(1=>1));\n\njulia> add_arc!(fst, 1, 2, 1, 1, 1.0);\n\njulia> add_arc!(fst, 1, 5, 1, 1, 1.0);\n\njulia> add_arc!(fst, 1, 3, 1, 1, 1.0);\n\njulia> add_arc!(fst, 2, 6, 1, 1, 1.0);\n\njulia> add_arc!(fst, 2, 4, 1, 1, 1.0);\n\njulia> add_arc!(fst, 5, 4, 1, 1, 1.0);\n\njulia> add_arc!(fst, 3, 4, 1, 1, 1.0);\n\njulia> add_arc!(fst, 3, 7, 1, 1, 1.0);\n\njulia> initial!(fst,1)\nWFST #states: 7, #arcs: 8, #isym: 1, #osym: 1\n|1/0.0f0|\n1:1/1.0f0 → (2)\n1:1/1.0f0 → (5)\n1:1/1.0f0 → (3)\n(2)\n1:1/1.0f0 → (6)\n1:1/1.0f0 → (4)\n(3)\n1:1/1.0f0 → (4)\n1:1/1.0f0 → (7)\n(4)\n(5)\n1:1/1.0f0 → (4)\n(6)\n(7)\n\njulia> dfs = FiniteStateTransducers.DFS(fst,1); # DFS starting from state 1\n\njulia> for (p,s,n,d,e,a) in dfs\n         println(\"$p,$s,$n\")\n         if d == true\n           println(\"visiting first time $n (Gray)\")\n         else\n           if e\n             println(\"completed state $s (Black)\")\n           else\n             println(\"node $n already visited\")\n           end\n         end\n       end\n0,1,2\nvisiting first time 2 (Gray)\n1,2,6\nvisiting first time 6 (Gray)\n2,6,0\ncompleted state 6 (Black)\n1,2,4\nvisiting first time 4 (Gray)\n2,4,0\ncompleted state 4 (Black)\n1,2,0\ncompleted state 2 (Black)\n0,1,5\nvisiting first time 5 (Gray)\n1,5,4\nnode 4 already visited\n1,5,0\ncompleted state 5 (Black)\n0,1,3\nvisiting first time 3 (Gray)\n1,3,4\nnode 4 already visited\n1,3,7\nvisiting first time 7 (Gray)\n3,7,0\ncompleted state 7 (Black)\n1,3,0\ncompleted state 3 (Black)\n0,1,0\ncompleted state 1 (Black)\n\n\n\n\n\n\n","category":"type"},{"location":"4_algorithms/#FiniteStateTransducers.is_visited","page":"Algorithms","title":"FiniteStateTransducers.is_visited","text":"is_visited(fst::WFST, i = get_initial(fst;single=true))\n\nReturn an array of booleans indicating if the i-th state of the fst is visted starting form i.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Reverse","page":"Algorithms","title":"Reverse","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"reverse","category":"page"},{"location":"4_algorithms/#Base.reverse","page":"Algorithms","title":"Base.reverse","text":"reverse(fst::WFST)\n\nReturns rfst, the reversed version of fst. If fst transuces the sequence x to y with weight w, rfst transuces the reverse of x to the reverse of y with weight reverse(w).\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Shortest-Distance","page":"Algorithms","title":"Shortest Distance","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"shortest_distance","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.shortest_distance","page":"Algorithms","title":"FiniteStateTransducers.shortest_distance","text":"shortest_distance(fst[, s=get_initial(fst); filter=arc->true, reverse=false)\n\nComputes the shortest distance between the state s to every other state. The shortest distance between s and i is defined as the sum of the weights of all paths between these states.\n\nWeights are required to be rigth distributive and k-closed.\n\nIf fst has N states a N-long vector is returned where the i-the element contains the shortest distance between the states s and i.\n\nIf reversed==true the shortest distance from the final states is computed. In this case s has no effect since a new initial superstate is added to the reversed WFST. Here weights are required to be left distributive and k-closed. \n\nSee Mohri \"Semiring framework and algorithms for shortest-distance problems\", Journal of Automata, Languages and Combinatorics 7(3): 321-350, 2002.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#Topological-sort","page":"Algorithms","title":"Topological sort","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"topsort\ntopsortperm\nget_scc","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.topsort","page":"Algorithms","title":"FiniteStateTransducers.topsort","text":"topsort(fst::WFST, i = get_initial(fst); filter=arc->true)\n\nRequires fst to be acyclic.\n\nReturns an equivalent WFST to fst which is topologically sorted starting from the i-th state.\n\nModify the filter function to perform the operation considering only specific arcs.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.topsortperm","page":"Algorithms","title":"FiniteStateTransducers.topsortperm","text":"topsortperm(fst::WFST, i = get_initial(fst); filter=arc->true)\n\nRequires fst to be acyclic.\n\nReturns the topological permutation of states of fst starting from the i-th state.\n\nModify the filter function to perform the operation considering only specific arcs.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#FiniteStateTransducers.get_scc","page":"Algorithms","title":"FiniteStateTransducers.get_scc","text":"get_scc(fst::WFST, i = get_initial(fst;single=true); filter=arc->true)\n\nCalculates the strongly connected components of 'fst' using Tarjan's algorithm. Returns a tuple (scc,c,v):\n\nscc are the strongly connected components of fst\nc is a boolean array containing the accessibility form the i\nv are the visited states of the fst\n\nThe function filter can be used to consider only arcs with specific properties.\n\n\n\n\n\n","category":"function"},{"location":"4_algorithms/#WFST-label-transition-extraction","page":"Algorithms","title":"WFST label transition extraction","text":"","category":"section"},{"location":"4_algorithms/","page":"Algorithms","title":"Algorithms","text":"wfst2tr","category":"page"},{"location":"4_algorithms/#FiniteStateTransducers.wfst2tr","page":"Algorithms","title":"FiniteStateTransducers.wfst2tr","text":"wfst2tr(fst,Nt; get_label=get_ilabel)\n\nReturns an array time2tr of length Nt-1. The t-th element of time2tr is a dictionary mapping the transition index between input label at time t to the input label at time t+1.\n\njulia> using FiniteStateTransducers\n\njulia> H = WFST([\"a1\",\"a2\",\"a3\"],[\"a\"]);\n\njulia> add_arc!(H,1,2,\"a1\",\"a\");\n\njulia> add_arc!(H,2,3,\"a2\",\"<eps>\");\n\njulia> add_arc!(H,2,2,\"a2\",\"<eps>\");\n\njulia> add_arc!(H,3,4,\"a3\",\"<eps>\");\n\njulia> add_arc!(H,3,2,\"a3\",\"a\");\n\njulia> initial!(H,1);\n\njulia> final!(H,4)\nWFST #states: 4, #arcs: 5, #isym: 3, #osym: 1\n|1/0.0f0|\na1:a/0.0f0 → (2)\n(2)\na2:ϵ/0.0f0 → (3)\na2:ϵ/0.0f0 → (2)\n(3)\na3:ϵ/0.0f0 → (4)\na3:a/0.0f0 → (2)\n((4/0.0f0))\n\n\njulia> Nt = 10;\n\njulia> time2tr = wfst2tr(H,Nt)\n9-element Array{Dict{Int64,Array{Int64,1}},1}:\n Dict(1 => [2])\n Dict(2 => [2, 3])\n Dict(2 => [2, 3],3 => [2])\n Dict(2 => [2, 3],3 => [2])\n Dict(2 => [2, 3],3 => [2])\n Dict(2 => [2, 3],3 => [2])\n Dict(2 => [2, 3],3 => [2])\n Dict(2 => [2],3 => [2])\n Dict(2 => [3])\n\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#WFSTs-internals","page":"Contructing WFSTs","title":"WFSTs internals","text":"","category":"section"},{"location":"3_wfsts/#Formal-definition","page":"Contructing WFSTs","title":"Formal definition","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Formally a WFSTs over the semiring mathbbW is the tuple (mathcalAmathcalBQIFElambdarho) where:","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"mathcalA is the input alphabet (set of input labels)\nmathcalB is the output alphabet (set of output labels)\nQ is a set of states (usually integers)\nI subseteq Q is the set of initial states\nF subseteq Q is the set of final states\nE subseteq Q times mathcalA cup  epsilon  times mathcalB cup  epsilon  times mathbbW times Q is a set of arcs (transitions) where an element consist of the tuple (starting state,input label, output label, weigth, destination state)\nlambda  I rightarrow mathbbW a function that maps initial states to a weight \nrho  F rightarrow mathbbW a function that maps final states to a weight ","category":"page"},{"location":"3_wfsts/#Constructors-and-modifiers","page":"Contructing WFSTs","title":"Constructors and modifiers","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"WFST\nadd_arc!\nadd_states!\ninitial!\nfinal!\nrm_final!\nrm_initial!","category":"page"},{"location":"3_wfsts/#FiniteStateTransducers.WFST","page":"Contructing WFSTs","title":"FiniteStateTransducers.WFST","text":"WFST(isym, [osym]; W = TropicalWeight{Float32})\n\nConstruct an empty Weighted Finite State Transducer (WFST)\n\nisym input symbol table (can be a dictionary or a vector)\nosym output symbol dictionary (optional)\nW weight type\n\nIf the symbol table are AbstractDict{I,D}, D must be an integer and I the type of the symbol.\n\n\n\n\n\n","category":"type"},{"location":"3_wfsts/#FiniteStateTransducers.add_arc!","page":"Contructing WFSTs","title":"FiniteStateTransducers.add_arc!","text":"add_arc!(fst, src, dest, ilabel, olabel[, w=one(W)])\n\nadd_arc!(fst, srcdest::Pair, ilabelolabel::Pair[, w=one(W)])\n\nAdds an arc from state src to state dest with input label ilabel, output label olabel and weight w. Alternative notation utilizes Pairs.\n\nIf w is not provided this defaults to one(W) where W is the weight type of fst.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.add_states!","page":"Contructing WFSTs","title":"FiniteStateTransducers.add_states!","text":"add_states!(fst,N)\n\nAdd N empty states to the FST.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.initial!","page":"Contructing WFSTs","title":"FiniteStateTransducers.initial!","text":"initial!(fst::WFST{W},i, [w=one(W)])\n\nSet the i-th state as a initial state. A weight w can also be provided.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.final!","page":"Contructing WFSTs","title":"FiniteStateTransducers.final!","text":"final!(fst::WFST{W},i, [w=one(W)])\n\nSet the i-th state as a final state. A weight w can also be provided.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.rm_final!","page":"Contructing WFSTs","title":"FiniteStateTransducers.rm_final!","text":"rm_final!(fst,i)\n\nRemove final state labeling of the i-th state.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.rm_initial!","page":"Contructing WFSTs","title":"FiniteStateTransducers.rm_initial!","text":"rm_initial!(fst,i)\n\nRemove initial state labeling of the state i.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#Internal-access","page":"Contructing WFSTs","title":"Internal access","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"get_isym\nget_iisym\nget_osym\nget_iosym\nget_states\nget_initial\nget_initial_weight\nget_final\nget_final_weight\nget_ialphabet\nget_oalphabet\nget_arcs","category":"page"},{"location":"3_wfsts/#FiniteStateTransducers.get_isym","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_isym","text":"get_isym(fst::WFST)\n\nReturns the input symbol table of fst. The table consists of a dictionary where each element goes from the symbol to the corresponding index.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_iisym","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_iisym","text":"get_iisym(fst::WFST)\n\nReturns the inverted input symbol table.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_osym","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_osym","text":"get_osym(fst::WFST)\n\nReturns the output symbol table of fst. The table consists of a dictionary where each element goes from the symbol to the corresponding index. \n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_iosym","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_iosym","text":"get_iosym(fst::WFST)\n\nReturns the inverted output symbol table.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_states","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_states","text":"get_states(fst::WFST)\n\nReturns the states the fst.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_initial","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_initial","text":"get_initial(fst::WFST, [single=false])\n\nReturns the initial state id of the fst. If single is true the first initial state is returned.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_initial_weight","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_initial_weight","text":"get_initial_weight(fst::WFST,i)\n\nReturns the weight of initial i-th state of fst. \n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_final","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_final","text":"get_final(fst::WFST, [single=false])\n\nReturns the final state id of the fst. If single is true the first final state is returned.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_final_weight","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_final_weight","text":"get_final_weight(fst::WFST,i)\n\nReturns the weight of i-th final state of fst. \n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_ialphabet","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_ialphabet","text":"get_ialphabet(label::fst)\n\nReturns the alphabet of the input labels of fst. The alphabet is defined as the set of symbols composing the input or output labels.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_oalphabet","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_oalphabet","text":"get_oalphabet(label::fst)\n\nReturns the alphabet of the output labels of fst. The alphabet is defined as the set of symbols composing the input or output labels.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_arcs","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_arcs","text":"get_arcs(fst::WFST) = ArcIterator(fst)\n\nReturns an iterator that can be used to loop through all of the arcs of fst.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#Arcs","page":"Contructing WFSTs","title":"Arcs","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Arc\nget_ilabel\nget_olabel\nget_weight\nget_nextstate","category":"page"},{"location":"3_wfsts/#FiniteStateTransducers.Arc","page":"Contructing WFSTs","title":"FiniteStateTransducers.Arc","text":"Arc(ilab::Int,olab::Int,w::W,n::Int)\n\nConstructs an arc with input label ilab, output label olab, weight 'weight' and nextstate n. ilab and olab must be integers consistent with a input/output symbol table of the WFST at use.\n\nMainly used for internals see add_arc! for a simpler way of adding arcs to a WFST.   \n\n\n\n\n\n","category":"type"},{"location":"3_wfsts/#FiniteStateTransducers.get_ilabel","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_ilabel","text":"get_ilabel(A::Arc)\n\nReturns the input label index of the arc A.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_olabel","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_olabel","text":"get_olabel(A::Arc)\n\nReturns the input label index of the arc A.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_weight","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_weight","text":"get_weight(A::Arc)\n\nReturns the weight the arc A.\n\n\n\n\n\nget_weight(fst::WFST,i)\n\nReturns the weight of the i-th state of fst. If there is no weight nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_nextstate","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_nextstate","text":"get_nextstate(A::Arc)\n\nReturns the state that the arc A is pointing to.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#Paths","page":"Contructing WFSTs","title":"Paths","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Path\nget_isequence\nget_osequence","category":"page"},{"location":"3_wfsts/#FiniteStateTransducers.Path","page":"Contructing WFSTs","title":"FiniteStateTransducers.Path","text":"Path(isym[,osym], iolabel::Pair, w=one(TropicalWeight{Float32}))\n\nConstruct a path with input and output symbol table isym and (optional) osym (see WFST).\n\niolabel is a Pair of vectors.\n\njulia> isym = [\"a\",\"b\",\"c\",\"d\"];\n\njulia> osym = [\"α\",\"β\",\"γ\",\"δ\"];\n\njulia> W = ProbabilityWeight{Float32};\n\njulia> p = Path(isym,osym,[\"a\",\"b\",\"c\"] => [\"α\",\"β\",\"γ\"], one(W))\n[\"a\", \"b\", \"c\"] → [\"α\", \"β\", \"γ\"], w:1.0f0\n\n\nThe weight of a path of a WFST results from the multiplication (otimes) of the weights of the different arcs that are transversed. See e.g. get_paths to extract paths from a WFST.\n\njulia> p * Path(isym,osym,[\"d\"] => [\"δ\"], W(0.5))\n[\"a\", \"b\", \"c\", \"d\"] → [\"α\", \"β\", \"γ\", \"δ\"], w:0.5f0\n\n\n\n\n\n\n","category":"type"},{"location":"3_wfsts/#FiniteStateTransducers.get_isequence","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_isequence","text":"get_isequence(p::Path)\n\nReturns the input sequence of the path p.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_osequence","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_osequence","text":"get_osequence(p::Path)\n\nReturns the output sequence of the path p.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#Tour-of-the-internals","page":"Contructing WFSTs","title":"Tour of the internals","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Let's build a simple WFST and check out its internals: ","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"julia> using FiniteStateTransducers\n\njulia> A = WFST([\"hello\",\"world\"],[:ciao,:mondo]);\n\njulia> add_arc!(A,1=>2,\"hello\"=>:ciao);\n\njulia> add_arc!(A,1=>3,\"world\"=>:mondo);\n\njulia> add_arc!(A,2=>3,\"world\"=>:mondo);\n\njulia> initial!(A,1);\n\njulia> final!(A,3)\nWFST #states: 3, #arcs: 3, #isym: 2, #osym: 2\n|1/0.0f0|\nhello:ciao/0.0f0 → (2)\nworld:mondo/0.0f0 → (3)\n(2)\nworld:mondo/0.0f0 → (3)\n((3/0.0f0))\n","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"For this simple WFST the states consists of an Array of Arrays containing Arc:","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"julia> get_states(A)\n3-element Array{Array{FiniteStateTransducers.Arc{TropicalWeight{Float32},Int64},1},1}:\n [1:1/0.0f0 → (2), 2:2/0.0f0 → (3)]\n [2:2/0.0f0 → (3)]\n []","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"As it can be seen the first state has two arcs, second state only one and the final state none. A state can also be accessed as follows:","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"julia> A[2]\n1-element Array{FiniteStateTransducers.Arc{TropicalWeight{Float32},Int64},1}:\n 2:2/0.0f0 → (3)","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Here the arc's input/output labels are displayed as integers. We would expect world:mondo/0.0f0 → (3) instead of 2:2/0.0f0 → (3).  This is due to fact that, contrary to the formal definition, labels are not stored directly in the arcs but an index is used instead, which corresponds to the input/output symbol table:","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"julia> get_isym(A)\nDict{String,Int64} with 2 entries:\n  \"hello\" => 1\n  \"world\" => 2\n\njulia> get_osym(A)\nDict{Symbol,Int64} with 2 entries:\n  :mondo => 2\n  :ciao  => 1","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Another difference is in the definition of I, F, lambda and rho. These are also represented by dictionaries that can be accessed using the functions get_initial and get_final.","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"julia> get_final(A)\nDict{Int64,TropicalWeight{Float32}} with 1 entry:\n  3 => 0.0\n","category":"page"},{"location":"3_wfsts/#Epsilon-label","page":"Contructing WFSTs","title":"Epsilon label","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"iseps\nget_eps","category":"page"},{"location":"3_wfsts/#FiniteStateTransducers.iseps","page":"Contructing WFSTs","title":"FiniteStateTransducers.iseps","text":"iseps(x)\n\nChecks if x is the epsilon label. Defined only for String and Int, where <eps> and 0 are the epsilon symbols. Extend this method if you want to create WFST with a user defined type.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.get_eps","page":"Contructing WFSTs","title":"FiniteStateTransducers.get_eps","text":"get_eps(x::Type)\n\nReturns the epsilon label for a given Type. Defined only for String and Int, where <eps> and 0 are the epsilon symbols. Extend this method if you want to create WFST with a user defined type.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"By default 0 indicates the epsilon label which is not present in the symbol table.","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Currently the following epsilon symbols are reserved for the following types:","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"Type Label\nChar 'ϵ'\nString \"<eps>\"\nInt 0","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"We can define a particular type by extending the functions iseps and get_eps. For example if we want to introduce an epsilon symbol for the type Symbol:","category":"page"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"julia> FiniteStateTransducers.iseps(x::Symbol) = x == :eps;\n\njulia> FiniteStateTransducers.get_eps(x::Type{Symbol}) = :eps;\n\njulia> add_arc!(A,3=>3,\"world\"=>:eps)\nWFST #states: 3, #arcs: 5, #isym: 2, #osym: 2\n|1/0.0f0|\nhello:ciao/0.0f0 → (2)\nworld:mondo/0.0f0 → (3)\n(2)\nworld:mondo/0.0f0 → (3)\n((3/0.0f0))\nworld:ϵ/0.0f0 → (3)\n\njulia> A[3]\n1-element Array{Arc{TropicalWeight{Float32},Int64},1}:\n 2:0/0.0f0 → (3)","category":"page"},{"location":"3_wfsts/#Properties","page":"Contructing WFSTs","title":"Properties","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"length\nsize\nisinitial\nisfinal\ntypeofweight\nhas_eps\ncount_eps\nis_acceptor\nis_acyclic\nis_deterministic","category":"page"},{"location":"3_wfsts/#Base.length","page":"Contructing WFSTs","title":"Base.length","text":"length(fst::WFST)\n\nReturns the number of states of the fst.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#Base.size","page":"Contructing WFSTs","title":"Base.size","text":"size(fst::WFST,[i])\n\nReturns number of states and total number of arcs in a tuple. If 'i=1' returns the number of states and if i=2 the number of arcs. \n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.isinitial","page":"Contructing WFSTs","title":"FiniteStateTransducers.isinitial","text":"isinitial(fst::WFST, i)\n\nCheck if the i-th state is an initial state.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.isfinal","page":"Contructing WFSTs","title":"FiniteStateTransducers.isfinal","text":"isfinal(fst::WFST, i)\n\nCheck if the i-th state is an final state.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.typeofweight","page":"Contructing WFSTs","title":"FiniteStateTransducers.typeofweight","text":"typeofweight(fst_or_path)\n\nReturns the weight type of a WFST or a path.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.has_eps","page":"Contructing WFSTs","title":"FiniteStateTransducers.has_eps","text":"has_eps([label::Function,] fst::FST)\n\nCheck if fst has epsilon transition in either input or output labels. To specify input or output plug in either get_ilabel or get_olabel respectively in label. \n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.count_eps","page":"Contructing WFSTs","title":"FiniteStateTransducers.count_eps","text":"count_eps(label::Function, fst::FST)\n\nReturns number of epsilon transition of either input or output labels. To specify input or output plug in ilabel and olabel respectively in label. \n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.is_acceptor","page":"Contructing WFSTs","title":"FiniteStateTransducers.is_acceptor","text":"is_acceptor(fst::WFST)\n\nReturns true if fst is an acceptor, i.e. if all arcs have equal input and output labels.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.is_acyclic","page":"Contructing WFSTs","title":"FiniteStateTransducers.is_acyclic","text":"is_acyclic(fst::WFST[,i = get_initial(fst;single=true)]; kwargs...)\n\nReturns the number of states of the fst. For kwargs see DFS.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.is_deterministic","page":"Contructing WFSTs","title":"FiniteStateTransducers.is_deterministic","text":"is_deterministic(fst::WFST; get_label=get_ilabel)\n\nReturns true if fst is deterministic in the input labels. A input label deterministic WFST must have a single initial state and arcs leaving any state do not share the same input label.\n\nChange the keyword get_label to get_olabel in order to check determinism in the output labels.\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#Other-constructors","page":"Contructing WFSTs","title":"Other constructors","text":"","category":"section"},{"location":"3_wfsts/","page":"Contructing WFSTs","title":"Contructing WFSTs","text":"linearfst\nmatrix2wfst","category":"page"},{"location":"3_wfsts/#FiniteStateTransducers.linearfst","page":"Contructing WFSTs","title":"FiniteStateTransducers.linearfst","text":"linearfst(ilabels,olabels,w,[isym,[osym=isym]]; W=TropicalWeight{Float32})\n\nCreates a linear WFST. ilabels, olabels and w are the input labels, output labels and weights respectively which must be vectors of the same size. If input and output tables isym and osym are not provided, the symbol tables are derived from ilabels and olabels.\n\njulia> A = linearfst([1,1,3,4],[:a,:b,:c,:d],ones(TropicalWeight{Float64},4))\nWFST #states: 5, #arcs: 4, #isym: 3, #osym: 4\n|1/0.0|\n1:a/0.0 → (2)\n(2)\n1:b/0.0 → (3)\n(3)\n3:c/0.0 → (4)\n(4)\n4:d/0.0 → (5)\n((5/0.0))\n\n\n\n\n\n\n","category":"function"},{"location":"3_wfsts/#FiniteStateTransducers.matrix2wfst","page":"Contructing WFSTs","title":"FiniteStateTransducers.matrix2wfst","text":"matrix2wfst(isym,[osym,] X; W = TropicalWeight{Float32})\n\nCreates a WFST with weight type W and input output tables isym and osym using the matrix X. If X is a matrix of dimensions NsxNt, the resulting WFST will have Nt+1 states. Arcs form the t-th state of fst will go only to the t+1-th state and will correspond to the non-zero element of the t-th column of X. State 1 and Nt+1 are labelled as initial and final state, respectively.\n\njulia> matrix2wfst([\"a\",\"b\",\"c\"],[1 2 3; 1 2 3; 1 2 3])\nWFST #states: 4, #arcs: 9, #isym: 3, #osym: 3\n|1/0.0f0|\na:a/1.0f0 → (2)\nb:b/1.0f0 → (2)\nc:c/1.0f0 → (2)\n(2)\na:a/2.0f0 → (3)\nb:b/2.0f0 → (3)\nc:c/2.0f0 → (3)\n(3)\na:a/3.0f0 → (4)\nb:b/3.0f0 → (4)\nc:c/3.0f0 → (4)\n((4/0.0f0))\n\n\n\n\n\n\n","category":"function"},{"location":"1_intro/#intro","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"1_intro/#Weighted-Finite-State-Transducers","page":"Introduction","title":"Weighted Finite State Transducers","text":"","category":"section"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"Weighted finite state transducers (WFSTs) are graphs capable of translating an input sequence of symbols to an output sequence of symbols and associate a particular weight to this conversion. ","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"Firstly we define the input and output symbols:","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"julia> isym = [s for s in \"hello\"];\n\njulia> osym = [s for s in \"world\"];\n","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"We can construct a WFST by adding arcs, where each arc has an input label, an output label and a weight (which is typically defined in a particular semiring):","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"julia> using FiniteStateTransducers\n\njulia> W = ProbabilityWeight{Float64} # weight type\n\njulia> A = WFST(isym,osym; W=W); # empty wfst\n\njulia> add_arc!(A,1=>2,'h'=>'w',1); # arc from state 1 to 2 with in label 'h' and out label 'w' and weight 1\n\njulia> add_arc!(A,2=>3,'e'=>'o',1); # arc from state 2 to 3 with in label 'e' and out label 'w' and weight 0.5\n\njulia> add_arc!(A,3=>4,'l'=>'r',1);\n\njulia> add_arc!(A,4=>5,'l'=>'l',1); \n\njulia> add_arc!(A,5=>6,'o'=>'d',1);\n\njulia> initial!(A,1); final!(A,6) # set initial and final state\nWFST #states: 6, #arcs: 5, #isym: 4, #osym: 5\n|1/1.0|\nh:w/1.0 → (2)\n(2)\ne:o/1.0 → (3)\n(3)\nl:r/1.0 → (4)\n(4)\nl:l/1.0 → (5)\n(5)\no:d/1.0 → (6)\n((6/1.0))\n","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"We can now plug the input sequence ['h','e','l','l','o'] into the WFST:","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"julia> A(['h','e','l','l','o'])\n(['w', 'o', 'r', 'l', 'd'], 1.0)\n","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"The input sequence is translated into ['w', 'o', 'r', 'l', 'd']  with probability 1.0. A sequence that cannot be accepted will return a null probability instead:","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"julia> A(['h','e','l','l'])\n(['w', 'o', 'r', 'l'], 0.0)\n","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"We could modify the WFST by adding an arc with an epsilon label, which is special symbol ϵ that can be skipped (see Sec. Epsilon label for more info):","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"julia> add_arc!(A,5=>6,'ϵ'=>'d',0.001);\n\njulia> A(['h','e','l','l'])\n(['w', 'o', 'r', 'l', 'd'], 0.001)\n","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"Here we used a small probability for this epsilon arc and this results in a low probability of the transduced output sequence. In fact the resulting probability of a sequence is the product of the weights of the arcs that were accessed (see Paths).","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"note: Note\nThe method (transduce::WFST)(ilabels::Vector) transduce the sequence of ilabel using the WFST fst requires the WFST to be input deterministic, see is_deterministic.","category":"page"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"See [1] for a good tutorial on WFST with the focus on speech recognition. ","category":"page"},{"location":"1_intro/#references","page":"Introduction","title":"References","text":"","category":"section"},{"location":"1_intro/","page":"Introduction","title":"Introduction","text":"[1] Mohri, Mehryar and Pereira, Fernando and Riley, Michael, \"Speech Recognition with Weighted Finite-State Transducers,\" Springer Handb. Speech Process. 2008","category":"page"},{"location":"5_io/#Input/output","page":"I/O","title":"Input/output","text":"","category":"section"},{"location":"5_io/","page":"I/O","title":"I/O","text":"txt2fst\ntxt2sym\nfst2dot\nfst2pdf","category":"page"},{"location":"5_io/#FiniteStateTransducers.txt2fst","page":"I/O","title":"FiniteStateTransducers.txt2fst","text":"txt2fst(path_or_text,isym[,osym];W=TropicalWeight{Float32})\n\nLoads a WFST from a text file using OpenFST format.\n\nisym and osym can be either dictionaries or paths to the input/output symbol list.\n\nIf path_or_text is not a path, the input string is parsed directly.\n\njulia> txt2fst(\"0 1 a a 3.0\n       1 2 b <eps> 77.0\n       2 3 c <eps> 33.0\n       3 4 d d 44.0\n       4 90.0\n       \",Dict(\"a\"=>1,\"b\"=>2,\"c\"=>3,\"d\"=>4))\nWFST #states: 5, #arcs: 4, #isym: 4, #osym: 4\n|1/0.0f0|\na:a/3.0f0 → (2)\n(2)\nb:ϵ/77.0f0 → (3)\n(3)\nc:ϵ/33.0f0 → (4)\n(4)\nd:d/44.0f0 → (5)\n((5/90.0f0))\n\n\n\n\n\n\n","category":"function"},{"location":"5_io/#FiniteStateTransducers.txt2sym","page":"I/O","title":"FiniteStateTransducers.txt2sym","text":"txt2sym(path)\n\nLoads a symbol list from a text file into a Dict using OpenFST convention.\n\n\n\n\n\n","category":"function"},{"location":"5_io/#FiniteStateTransducers.fst2dot","page":"I/O","title":"FiniteStateTransducers.fst2dot","text":"fst2dot(fst)\n\nConverts the fst to a string in the dot format.\n\nUseful to visualise large FSTs using Graphviz.\n\n\n\n\n\n","category":"function"},{"location":"5_io/#FiniteStateTransducers.fst2pdf","page":"I/O","title":"FiniteStateTransducers.fst2pdf","text":"fst2pdf(fst,pdffile)\n\nPrints the fst to a pdf file using Graphviz.\n\nRequires Graphviz to be intalled.\n\n\n\n\n\n","category":"function"},{"location":"2_semirings/#weights","page":"Weights","title":"Weights","text":"","category":"section"},{"location":"2_semirings/","page":"Weights","title":"Weights","text":"The weights of WFSTs typically belong to particular semirings. The two binary operations oplus and otimes are exported as + and *. The null element bar0 and unity element bar1 can be obtained using the functions zero(W) and one(W) where W<:Semiring.","category":"page"},{"location":"2_semirings/#Semirings","page":"Weights","title":"Semirings","text":"","category":"section"},{"location":"2_semirings/","page":"Weights","title":"Weights","text":"ProbabilityWeight\nLogWeight\nNLogWeight\nTropicalWeight\nBoolWeight\nLeftStringWeight\nRightStringWeight\nProductWeight","category":"page"},{"location":"2_semirings/#FiniteStateTransducers.ProbabilityWeight","page":"Weights","title":"FiniteStateTransducers.ProbabilityWeight","text":"ProbabilityWeight(x)\n\nSet oplus otimes bar0 bar1\nmathbbR + * 0 1\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/#FiniteStateTransducers.LogWeight","page":"Weights","title":"FiniteStateTransducers.LogWeight","text":"LogWeight(x)\n\nSet oplus otimes bar0 bar1\nmathbbRcuppminfty log(e^x+e^y) + -infty 0\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/#FiniteStateTransducers.NLogWeight","page":"Weights","title":"FiniteStateTransducers.NLogWeight","text":"NLogWeight(x)\n\nSet oplus otimes bar0 bar1\nmathbbRcuppminfty -log(e^-x+e^-y) + infty 0\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/#FiniteStateTransducers.TropicalWeight","page":"Weights","title":"FiniteStateTransducers.TropicalWeight","text":"TropicalWeight(x)\n\nSet oplus otimes bar0 bar1\nmathbbRcuppminfty min + infty 0\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/#FiniteStateTransducers.BoolWeight","page":"Weights","title":"FiniteStateTransducers.BoolWeight","text":"BoolWeight(x::Bool)\n\nSet oplus otimes bar0 bar1\n01 lor land 0 1\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/#FiniteStateTransducers.LeftStringWeight","page":"Weights","title":"FiniteStateTransducers.LeftStringWeight","text":"LeftStringWeight(x)\n\nSet oplus otimes bar0 bar1\nL^*cupinfty longest common prefix cdot infty epsilon\n\nwhere L^* is Kleene closure of the set of characters L and epsilon the empty string.\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/#FiniteStateTransducers.RightStringWeight","page":"Weights","title":"FiniteStateTransducers.RightStringWeight","text":"RightStringWeight(x)\n\nSet oplus otimes bar0 bar1\nL^*cupinfty longest common suffix cdot infty epsilon\n\nwhere L^* is Kleene closure of the set of characters L and epsilon the empty string.\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/#FiniteStateTransducers.ProductWeight","page":"Weights","title":"FiniteStateTransducers.ProductWeight","text":"ProductWeight(x...)\n\nSet oplus otimes bar0 bar1\nmathbbW_1times dotstimesmathbbW_N oplus_mathbbW_1 times dotstimesoplus_mathbbW_N otimes_mathbbW_1 times dotstimesotimes_mathbbW_N (bar0_mathbbW_1dotsbar0_mathbbW_N) (bar1_mathbbW_1dotsbar1_mathbbW_N)\n\n\n\n\n\n","category":"type"},{"location":"2_semirings/","page":"Weights","title":"Weights","text":"Use get to extract the contained object by the semiring:","category":"page"},{"location":"2_semirings/","page":"Weights","title":"Weights","text":"julia> w = TropicalWeight{Float32}(2.3)\n2.3f0\n\njulia> typeof(w), typeof(get(w))\n(TropicalWeight{Float32}, Float32)\n","category":"page"},{"location":"2_semirings/#Semiring-properties","page":"Weights","title":"Semiring properties","text":"","category":"section"},{"location":"2_semirings/","page":"Weights","title":"Weights","text":"Some algorithms are only available for WFST's whose weights belong to semirings that satisfies certain properties. A list of these properties follows:","category":"page"},{"location":"2_semirings/","page":"Weights","title":"Weights","text":"FiniteStateTransducers.iscommulative\nFiniteStateTransducers.isleft\nFiniteStateTransducers.isright\nFiniteStateTransducers.isweaklydivisible\nFiniteStateTransducers.ispath\nFiniteStateTransducers.isidempotent","category":"page"},{"location":"2_semirings/#FiniteStateTransducers.iscommulative","page":"Weights","title":"FiniteStateTransducers.iscommulative","text":"iscommulative(::Type{W})\n\nCheck if the semiring type W satisfies:\n\nforall ab in mathbbW a otimes b = b otimes a\n\n\n\n\n\n","category":"function"},{"location":"2_semirings/#FiniteStateTransducers.isleft","page":"Weights","title":"FiniteStateTransducers.isleft","text":"isleft(::Type{W})\n\nCheck if the semiring type W satisfies:\n\nforall abc in mathbbW  c otimes(a oplus b) = c otimes a oplus c otimes b\n\n\n\n\n\n","category":"function"},{"location":"2_semirings/#FiniteStateTransducers.isright","page":"Weights","title":"FiniteStateTransducers.isright","text":"isright(::Type{W})\n\nCheck if the semiring type W satisfies:\n\nforall abc in mathbbW  c otimes(a oplus b) = a otimes c oplus b otimes c\n\n\n\n\n\n","category":"function"},{"location":"2_semirings/#FiniteStateTransducers.isweaklydivisible","page":"Weights","title":"FiniteStateTransducers.isweaklydivisible","text":"isweaklydivisible(::Type{W})\n\nCheck if the semiring type W satisfies:\n\nforall ab in mathbbW  textst  a oplus b neq bar0  exists z  x = (x oplus y ) otimes z\n\n\n\n\n\n","category":"function"},{"location":"2_semirings/#FiniteStateTransducers.ispath","page":"Weights","title":"FiniteStateTransducers.ispath","text":"ispath(::Type{W})\n\nCheck if the semiring type W satisfies:\n\nforall ab in mathbbW a oplus b = a lor a oplus b = b\n\n\n\n\n\n","category":"function"},{"location":"2_semirings/#FiniteStateTransducers.isidempotent","page":"Weights","title":"FiniteStateTransducers.isidempotent","text":"isidempotent(::Type{W})\n\nCheck if the semiring type W satisfies:\n\nforall a in mathbbW a oplus a = a\n\n\n\n\n\n","category":"function"},{"location":"2_semirings/","page":"Weights","title":"Weights","text":"Notice that these functions are not exported by the package.","category":"page"},{"location":"#FiniteStateTransducers.jl","page":"Home","title":"FiniteStateTransducers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Play with Weighted Finite State Transducers (WFSTs) using the Julia language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"WFSTs provide a powerful framework that assigns a weight (e.g. probability) to conversions of symbol sequences.  WFSTs are used in many applications such as speech recognition, natural language processing and machine learning.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package takes a lot of inspiration from OpenFST.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FiniteStateTransducers is still in an early development stage, see the documentation for currently available features and issues for the missing ones.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, simply issue the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add FiniteStateTransducers","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was developed under  the supsrvision of Prof. Dr. Hervé Bourlard and supported by the Swiss National Science Foundation under the project  \"Sparse and hierarchical Structures for Speech Modeling\" (SHISSM) (no. 200021.175589).","category":"page"}]
}
